// src/lib/openai-secure.ts - VERS√ÉO SEGURA COM EDGE FUNCTION
import { supabase } from './supabase';

// üî• Fun√ß√£o auxiliar para data brasileira em formato string
function getBrazilDateString(): string {
  const now = new Date();
  const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
  const brazilTime = new Date(utc + (-3 * 3600000)); // UTC-3
  const year = brazilTime.getFullYear();
  const month = String(brazilTime.getMonth() + 1).padStart(2, '0');
  const day = String(brazilTime.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

interface ChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface ExpenseExtraction {
  valor: number;
  categoria: string;
  descricao: string;
  data: string;
  isValid: boolean;
}

export class SecureOpenAIService {
  private baseURL: string;
  
  constructor() {
    // ‚úÖ SEGURO: Usa Edge Function, n√£o OpenAI direto
    this.baseURL = `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/chat`;
  }

  async chatCompletion(messages: ChatMessage[], userId: string, systemInstructions?: string): Promise<string> {
    try {
      console.log('üîí Usando Edge Function SEGURA - API Key protegida!');
      
      // ‚úÖ REQUISI√á√ÉO SEGURA - Sem API Key exposta
      const response = await fetch(this.baseURL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_ANON_KEY}`, // ‚úÖ Chave p√∫blica
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: messages.map(msg => ({
            role: msg.role,
            content: msg.content
          })),
          userId,
          systemInstructions
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        
        if (response.status === 429) {
          throw new Error(errorData.error || 'üö´ Muitas requisi√ß√µes. Aguarde alguns minutos.');
        }
        
        if (response.status === 401) {
          throw new Error('üîê Erro de autentica√ß√£o. Recarregue a p√°gina.');
        }
        
        throw new Error(errorData.error || 'Erro na comunica√ß√£o com o servidor');
      }

      const data = await response.json();
      console.log('‚úÖ Resposta recebida da Edge Function segura');
      
      return data.response || '';
    } catch (error) {
      console.error('‚ùå Erro na Edge Function:', error);
      throw error;
    }
  }

  async extractExpenseData(
    userMessage: string, 
    systemInstructions: string, 
    conversationHistory: any[] = [],
    userPersonality?: string,
    userId?: string
  ): Promise<{
    response: string;
    extraction: ExpenseExtraction;
    personalityUpdate?: string;
  }> {
    console.log('üîç extractExpenseData chamado com:', { userMessage, historyLength: conversationHistory.length });
    
    // PRIORITY #1: DETEC√á√ÉO DE CONFIRMA√á√ÉO ANTES DE CHAMAR A API
    const currentMessage = userMessage.toLowerCase().trim();
    const confirmationWords = ['sim', 'ta sim', 't√° sim', 'certo', 'isso mesmo', 'exato', 'correto', 'confirmo', 'pode ser', 't√° certo', '√© isso', 'isso a√≠', 'ta certo'];
    const isConfirmation = confirmationWords.some(word => currentMessage.includes(word));
    
    console.log(`‚ùì Verificando confirma√ß√£o para: "${userMessage}"`);
    console.log(`‚úÖ √â confirma√ß√£o? ${isConfirmation}`);
    
    if (isConfirmation) {
      // Buscar a √∫ltima mensagem do bot que pediu confirma√ß√£o
      const botMessages = conversationHistory.filter(msg => msg.type === 'assistant');
      const lastBotMessage = botMessages[botMessages.length - 1];
      
      console.log(`ü§ñ √öltima mensagem do bot: "${lastBotMessage?.content}"`);
      
      if (lastBotMessage && lastBotMessage.content.includes('T√° certo?')) {
        // Extrair valor e categoria da mensagem do bot
        const valorMatch = lastBotMessage.content.match(/R\$\s*(\d+(?:[.,]\d+)?)/);
        const categoriaMatch = lastBotMessage.content.match(/em\s+([a-z√°√™√ß√£]+(?:\s+[a-z√°√™√ß√£]+)*?)(?:\s+(?:confirmado|registrado|anotado)|[^\w\s√°-√∫]|$)/i);
        
        console.log(`üí∞ Valor extra√≠do: ${valorMatch?.[1]}`);
        console.log(`üè∑Ô∏è Categoria extra√≠da: ${categoriaMatch?.[1]}`);
        
        if (valorMatch && categoriaMatch) {
          const valor = parseFloat(valorMatch[1].replace(',', '.'));
          let categoria = categoriaMatch[1].toLowerCase();
          
          // Mapear categorias corretamente
          console.log(`üîß Categoria original detectada: "${categoria}"`);
          
          // Mapear para categoria correta
          if (categoria.includes('aliment') || categoria.includes('hamburg') || categoria.includes('comida') || categoria.includes('caf√©') || categoria.includes('lanche')) {
            categoria = 'alimenta√ß√£o';
          } else if (categoria.includes('tecnolog') || categoria.includes('computador')) {
            categoria = 'tecnologia';
          } else if (categoria.includes('pet') || categoria.includes('veterinar')) {
            categoria = 'pets';
          } else if (categoria.includes('transport') || categoria.includes('uber') || categoria.includes('taxi')) {
            categoria = 'transporte';
          } else if (categoria.includes('mercad') || categoria.includes('supermerc') || categoria.includes('compra')) {
            categoria = 'mercado';
          } else if (categoria.includes('sa√∫de') || categoria.includes('saude') || categoria.includes('m√©dic') || categoria.includes('farm√°c')) {
            categoria = 'sa√∫de';
          } else if (categoria.includes('casa') || categoria.includes('m√≥v') || categoria.includes('decora√ß')) {
            categoria = 'casa';
          } else if (categoria.includes('conta') || categoria.includes('luz') || categoria.includes('√°gua') || categoria.includes('internet')) {
            categoria = 'contas';
          } else if (categoria.includes('lazer') || categoria.includes('cinema') || categoria.includes('festa')) {
            categoria = 'lazer';
          } else if (categoria.includes('roup') || categoria.includes('vestu√°r') || categoria.includes('sapato')) {
            categoria = 'vestu√°rio';
          } else if (categoria.includes('educa√ß') || categoria.includes('curso') || categoria.includes('livro')) {
            categoria = 'educa√ß√£o';
          } else if (categoria.includes('beleza') || categoria.includes('sal√£o') || categoria.includes('cabeleir')) {
            categoria = 'beleza';
          } else {
            categoria = 'outros';
          }
          
          console.log(`üéâ CONFIRMA√á√ÉO PROCESSADA: R$ ${valor} em ${categoria}`);
          
          return {
            response: `Massa! R$ ${valor.toFixed(2)} em ${categoria} registrado! üéâ\n\nGasto salvo com sucesso!\n\nE a√≠, rolou mais algum gasto que voc√™ quer anotar? üòä`,
            extraction: {
              valor: valor,
              categoria: categoria,
              descricao: `Gasto confirmado em ${categoria}`,
              data: getBrazilDateString(),
              isValid: true // FINALIZA!
            }
          };
        }
      }
    }
    
    // PRIORITY #2: RESPOSTA NEGATIVA PARA MAIS GASTOS
    const negativeResponses = ['rolou n√£o', 'rolou nao', 'n√£o rolou', 'nao rolou', 'nada', 'sem mais', 'por hoje n√£o', 'hoje n√£o', 'acabou', 's√≥ isso', 'nenhum', 'n√£o tem', 'nao tem'];
    const isNegativeResponse = negativeResponses.some(phrase => currentMessage.includes(phrase)) || 
                              (currentMessage === 'n√£o' || currentMessage === 'nao');
    
    if (isNegativeResponse) {
      const lastBotMessage = [...conversationHistory]
        .reverse()
        .find(msg => msg.type === 'assistant');
      
      if (lastBotMessage && lastBotMessage.content.includes('mais algum gasto')) {
        console.log('‚ùå RESPOSTA NEGATIVA PARA MAIS GASTOS DETECTADA');
        
        return {
          response: 'Show! Qualquer coisa, se aparecer mais algum gasto, √© s√≥ me chamar! T√¥ sempre aqui pra te ajudar! üòä‚úåÔ∏è',
          extraction: {
            valor: 0,
            categoria: '',
            descricao: '',
            data: getBrazilDateString(),
            isValid: false
          }
        };
      }
    }
    
    try {
      if (!userId) {
        throw new Error('User ID √© obrigat√≥rio para seguran√ßa');
      }

      // Preparar contexto da conversa
      const contextMessages: ChatMessage[] = [
        {
          role: 'system',
          content: this.buildSystemPrompt(systemInstructions, conversationHistory, userPersonality)
        },
        {
          role: 'user',
          content: userMessage
        }
      ];

      // ‚úÖ CHAMADA SEGURA
      const result = await this.chatCompletion(contextMessages, userId, systemInstructions);
      
      // Parse da resposta (mesmo c√≥digo do original)
      return this.parseExpenseResponse(result, userMessage, conversationHistory);
      
    } catch (error) {
      console.error('‚ùå Erro ao extrair dados de gasto:', error);
      throw error;
    }
  }

  private buildSystemPrompt(systemInstructions: string, conversationHistory: any[], userPersonality?: string): string {
    const personalityContext = userPersonality ? `
PERFIL DO USU√ÅRIO (aprenda e se adapte):
${userPersonality}

Com base no perfil, adapte seu jeito de falar para ficar mais pr√≥ximo do usu√°rio.
` : '';

    return `Voc√™ √© um assistente financeiro brasileiro SUPER INTELIGENTE! Use g√≠rias, seja natural e conecte TODAS as informa√ß√µes da conversa.

${personalityContext}

PERSONALIDADE MELHORADA:
- Fale como um brasileiro jovem e descontra√≠do
- Use g√≠rias tipo: "massa", "show", "beleza", "top", "valeu", "rolou", "maneiro", "demais", "dahora"
- Seja empolgado quando registrar gastos: "Opa!", "Show!", "Fechou!", "Mandou bem!"
- Use emojis com modera√ß√£o
- Seja EXTREMAMENTE INTELIGENTE e conecte informa√ß√µes entre mensagens
- SEMPRE LEMBRE valores mencionados anteriormente
- ENTENDA confirma√ß√µes: "sim", "ta sim", "certo", "isso mesmo", "exato", "correto"

SUPER INTELIG√äNCIA - CONTEXTO DA CONVERSA:
${conversationHistory.map((msg, index) => `${index + 1}. ${msg.type}: "${msg.content}"`).join('\n')}

L√ìGICA DE CONFIRMA√á√ÉO:
- Se a √∫ltima mensagem do bot perguntou "T√° certo?" e o usu√°rio responde "sim", "ta sim", "certo", "isso", "exato" ‚Üí REGISTRE o gasto e confirme com anima√ß√£o
- Se detectar confirma√ß√£o, use extraction da mensagem anterior do bot e marque isValid: true

REGRAS DE CONEX√ÉO CONTEXTUAL (MUITO IMPORTANTE):
1. üß† ANALISE TODA A CONVERSA - n√£o s√≥ a mensagem atual
2. üîó Se usu√°rio disse "gastei X" em qualquer mensagem anterior e agora menciona um produto/categoria, CONECTE!
3. ‚úÖ PRIMEIRA VEZ: Pergunte "T√° certo?" para confirmar
4. ‚úÖ CONFIRMA√á√ÉO: Se usu√°rio confirmar, registre e celebre: "Show! R$ X em Y registrado! üéâ"
5. üéØ Se encontrar VALOR + CATEGORIA (mesmo em mensagens separadas), pergunte confirma√ß√£o primeiro
6. ü§î Se n√£o conseguir conectar, pergunte de forma espec√≠fica

DETEC√á√ÉO DE CONFIRMA√á√ïES:
- Positivas: sim, ta sim, certo, isso mesmo, exato, correto, confirmo, pode ser, t√° certo, √© isso, isso a√≠
- Negativas: n√£o, nao, errado, n√£o √© isso, t√° errado

DETEC√á√ÉO INTELIGENTE DE CATEGORIAS (com sin√¥nimos e abrevia√ß√µes):
- alimenta√ß√£o: comida, almo√ßo, jantar, lanche, restaurante, pizza, hamb√∫rguer, hamburg, hamb, burger, burguer, habburg, churros, churro, mc, mcdonalds, bk, kfc, subway, ifood, delivery, caf√©, bar, bebida, picanha, carne, frango, peixe, feira, a√ßougue, padaria, sandu√≠che, sanduiche, food, fastfood, churrasco, churrascaria, alimentos, comer, eating, bebidas, suco, refrigerante, cerveja, vinho, √°gua, leite, caf√©, cappuccino
- vestu√°rio: roupa, roupas, camisa, cal√ßa, sapato, t√™nis, blusa, vestido, shorts, jaqueta, casaco, moda, camiseta, polo, social, bermuda, shopping, loja, lojas, magazine, renner, c&a, zara, riachuelo, bolsa, bolsas, sapatos, sneaker, chinelo, sand√°lia, bon√©, √≥culos, rel√≥gio
- transporte: uber, taxi, gasolina, combust√≠vel, posto, √¥nibus, metr√¥, trem, passagem, viagem, carro, moto, 99, cabify, aplicativo, transporte, deslocamento, ida, volta, corrida, carona
- mercado: supermercado, compras, mantimentos, feira, mercadinho, atacad√£o, assa√≠, carrefour, extra, p√£o de a√ß√∫car, walmart, compra, comprar, shopping, hipermercado
- lazer: cinema, festa, show, teatro, jogo, parque, balada, rol√™, divers√£o, netflix, streaming, spotify, ingresso, entretenimento, passeio, viagem, turismo, clube, academia
- sa√∫de: rem√©dio, m√©dico, farm√°cia, hospital, dentista, consulta, exame, tratamento, medicamento, drogaria, cl√≠nica, laborat√≥rio, check-up, fisioterapia
- casa: m√≥vel, sof√°, mesa, decora√ß√£o, limpeza, reforma, casa, lar, m√≥veis, eletrodom√©sticos, geladeira, fog√£o, microondas, tv, televis√£o, cama, colch√£o
- contas: luz, √°gua, internet, telefone, energia, g√°s, conta, fatura, boleto, presta√ß√£o, financiamento, cart√£o, taxa, iptu, ipva, seguro

FORMATO OBRIGAT√ìRIO (JSON):
{
  "response": "resposta_humanizada_com_confirmacao_ou_celebracao",
  "extraction": {
    "valor": numero_ou_0,
    "categoria": "categoria_ou_vazio",
    "descricao": "descri√ß√£o_natural_do_gasto",
    "data": "YYYY-MM-DD",
    "isValid": true_se_valor_E_categoria_identificados_E_confirmados
  },
  "personalityUpdate": "observacoes_sobre_o_jeito_do_usuario_falar"
}

EXEMPLOS DE FLUXO COMPLETO:
Usu√°rio: "gastei 200"
Bot: "Opa, R$ 200 anotado! Em que categoria?"
Usu√°rio: "hamb√∫rguer"  
Bot: "Show! R$ 200 no hamb√∫rguer! T√° certo?" (isValid: false - aguardando confirma√ß√£o)
Usu√°rio: "ta sim"
Bot: "Massa! R$ 200 em alimenta√ß√£o registrado! üéâ" (isValid: true - confirma e registra)

IMPORTANTE: 
- SEMPRE confirme antes de registrar gastos
- ENTENDA confirma√ß√µes do usu√°rio
- Celebre quando confirmado e registrado
- JSON v√°lido SEMPRE`;
  }

  private parseExpenseResponse(result: string, userMessage: string, conversationHistory: any[]): {
    response: string;
    extraction: ExpenseExtraction;
    personalityUpdate?: string;
  } {
    try {
      // Limpar resposta para garantir JSON v√°lido
      let cleanedResult = result.trim();
      if (!cleanedResult.startsWith('{')) {
        const jsonMatch = cleanedResult.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          cleanedResult = jsonMatch[0];
        } else {
          // Fallback parsing
          return this.createFallbackResponse(userMessage);
        }
      }
      
      const parsed = JSON.parse(cleanedResult);
      
      return {
        response: parsed.response || 'Opa, n√£o consegui processar direito...',
        extraction: {
          valor: parsed.extraction?.valor || 0,
          categoria: parsed.extraction?.categoria || '',
          descricao: parsed.extraction?.descricao || 'Gasto',
          data: parsed.extraction?.data || getBrazilDateString(),
          isValid: parsed.extraction?.isValid || false
        },
        personalityUpdate: parsed.personalityUpdate || ''
      };
      
    } catch (parseError) {
      console.error('‚ùå Erro ao fazer parse da resposta:', parseError);
      return this.createFallbackResponse(userMessage);
    }
  }

  private createFallbackResponse(userMessage: string): {
    response: string;
    extraction: ExpenseExtraction;
    personalityUpdate?: string;
  } {
    // Extra√ß√£o b√°sica de fallback
    let valor = 0;
    const numberMatch = userMessage.match(/\d+(?:[.,]\d+)?/);
    if (numberMatch) {
      valor = parseFloat(numberMatch[0].replace(',', '.'));
    }
    
    return {
      response: valor > 0 ? 
        `Opa, R$ ${valor.toFixed(2)} anotado! Mas em que categoria rolou esse gasto?` :
        'Opa, n√£o consegui sacar direito... Pode falar tipo "gastei R$ 50 no mercado"? üòÖ',
      extraction: {
        valor: valor,
        categoria: valor > 0 ? '' : 'outros',
        descricao: valor > 0 ? 'Gasto a categorizar' : 'Gasto',
        data: getBrazilDateString(),
        isValid: false
      }
    };
  }
}

// ‚úÖ INST√ÇNCIA SEGURA - Use esta ao inv√©s da OpenAIService original
export const secureOpenAI = new SecureOpenAIService();

/*
üîê BENEF√çCIOS DESTA VERS√ÉO:

‚úÖ API Key 100% SEGURA (s√≥ no servidor)
‚úÖ Rate limiting autom√°tico do Supabase
‚úÖ CORS configurado automaticamente
‚úÖ Logs de seguran√ßa detalhados
‚úÖ Tratamento de erros robusto
‚úÖ Valida√ß√£o de usu√°rio obrigat√≥ria
‚úÖ Mesma funcionalidade do original

üöÄ PARA USAR:

1. Configure a Edge Function no Supabase
2. Substitua OpenAIService por SecureOpenAIService no Chat.tsx
3. Remova a API Key do banco de dados
4. Profit! üéâ

EXEMPLO DE USO:
const result = await secureOpenAI.extractExpenseData(
  userMessage, 
  systemInstructions, 
  conversationHistory,
  userPersonality,
  userId // ‚úÖ Obrigat√≥rio para seguran√ßa
);
*/ 