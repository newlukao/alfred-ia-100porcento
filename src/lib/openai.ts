
interface ChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface ExpenseExtraction {
  valor: number;
  categoria: string;
  descricao: string;
  data: string;
  isValid: boolean;
}

export class OpenAIService {
  private apiKey: string;
  private baseURL = 'https://api.openai.com/v1/chat/completions';

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async chatCompletion(messages: ChatMessage[], model: string = 'gpt-4o-mini'): Promise<string> {
    try {
      const response = await fetch(this.baseURL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model,
          messages,
          temperature: 0.7,
          max_tokens: 400,
        }),
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const data = await response.json();
      return data.choices[0]?.message?.content || '';
    } catch (error) {
      console.error('Error calling OpenAI API:', error);
      throw error;
    }
  }

  async extractExpenseData(
    userMessage: string, 
    systemInstructions: string, 
    conversationHistory: any[] = [],
    userPersonality?: string
  ): Promise<{
    response: string;
    extraction: ExpenseExtraction;
    personalityUpdate?: string;
  }> {
    
    const personalityContext = userPersonality ? `
PERFIL DO USU√ÅRIO (aprenda e se adapte):
${userPersonality}

Com base no perfil, adapte seu jeito de falar para ficar mais pr√≥ximo do usu√°rio.
` : '';

    const extractionPrompt = `Voc√™ √© um assistente financeiro brasileiro SUPER INTELIGENTE! Use g√≠rias, seja natural e conecte TODAS as informa√ß√µes da conversa.

${personalityContext}

PERSONALIDADE MELHORADA:
- Fale como um brasileiro jovem e descontra√≠do
- Use g√≠rias tipo: "massa", "show", "beleza", "top", "valeu", "rolou", "maneiro", "demais", "dahora"
- Seja empolgado quando registrar gastos: "Opa!", "Show!", "Fechou!", "Mandou bem!"
- Use emojis com modera√ß√£o
- Seja EXTREMAMENTE INTELIGENTE e conecte informa√ß√µes entre mensagens
- SEMPRE LEMBRE valores mencionados anteriormente
- ENTENDA confirma√ß√µes: "sim", "ta sim", "certo", "isso mesmo", "exato", "correto"

SUPER INTELIG√äNCIA - CONTEXTO DA CONVERSA:
${conversationHistory.map((msg, index) => `${index + 1}. ${msg.type}: "${msg.content}"`).join('\n')}

L√ìGICA DE CONFIRMA√á√ÉO:
- Se a √∫ltima mensagem do bot perguntou "T√° certo?" e o usu√°rio responde "sim", "ta sim", "certo", "isso", "exato" ‚Üí REGISTRE o gasto e confirme com anima√ß√£o
- Se detectar confirma√ß√£o, use extraction da mensagem anterior do bot e marque isValid: true

REGRAS DE CONEX√ÉO CONTEXTUAL (MUITO IMPORTANTE):
1. üß† ANALISE TODA A CONVERSA - n√£o s√≥ a mensagem atual
2. üîó Se usu√°rio disse "gastei X" em qualquer mensagem anterior e agora menciona um produto/categoria, CONECTE!
3. ‚úÖ PRIMEIRA VEZ: Pergunte "T√° certo?" para confirmar
4. ‚úÖ CONFIRMA√á√ÉO: Se usu√°rio confirmar, registre e celebre: "Show! R$ X em Y registrado! üéâ"
5. üéØ Se encontrar VALOR + CATEGORIA (mesmo em mensagens separadas), pergunte confirma√ß√£o primeiro
6. ü§î Se n√£o conseguir conectar, pergunte de forma espec√≠fica

DETEC√á√ÉO DE CONFIRMA√á√ïES:
- Positivas: sim, ta sim, certo, isso mesmo, exato, correto, confirmo, pode ser, t√° certo, √© isso, isso a√≠
- Negativas: n√£o, nao, errado, n√£o √© isso, t√° errado

DETEC√á√ÉO INTELIGENTE DE CATEGORIAS (use sua intelig√™ncia para interpretar):
- alimenta√ß√£o: qualquer comida, bebida, restaurante, delivery, mercado (quando for comida)
- tecnologia: eletr√¥nicos, computadores, celulares, games, software, streaming
- vestu√°rio: roupas, sapatos, acess√≥rios, bolsas, √≥culos
- transporte: uber, taxi, gasolina, carro, moto, √¥nibus, passagens, consertos de ve√≠culo
- casa: m√≥veis, decora√ß√£o, utens√≠lios, eletrodom√©sticos, reforma, limpeza
- sa√∫de: rem√©dios, m√©dicos, dentista, exames, hospitais, farm√°cia
- lazer: cinema, shows, viagens, hot√©is, academia, livros, hobbies
- educa√ß√£o: cursos, faculdade, livros educacionais, material escolar
- beleza: sal√£o, cabelo, maquiagem, perfumes, produtos de beleza
- pets: veterin√°rio, ra√ß√£o, petshop, cuidados com animais
- mercado: supermercado, compras de mantimentos (n√£o comida pronta)
- contas: luz, √°gua, internet, telefone, aluguel, financiamentos

IMPORTANTE: USE SUA INTELIG√äNCIA! 
- "veterin√°rio" = pets (√≥bvio!)
- "shampoo" = beleza (√≥bvio!)
- "netflix" = tecnologia (√≥bvio!)
- "gasolina" = transporte (√≥bvio!)
- "pizza" = alimenta√ß√£o (√≥bvio!)

N√£o seja literal com palavras-chave. INTERPRETE o contexto como um humano faria!

N√öMEROS POR EXTENSO E VARIA√á√ïES:
- dez = 10, vinte = 20, trinta = 30, quarenta = 40, cinquenta = 50
- sessenta = 60, setenta = 70, oitenta = 80, noventa = 90, cem = 100
- duzentos = 200, trezentos = 300, quatrocentos = 400, quinhentos = 500
- mil = 1000, "um mil" = 1000, "dois mil" = 2000

FORMATO OBRIGAT√ìRIO (JSON):
{
  "response": "resposta_humanizada_com_confirmacao_ou_celebracao",
  "extraction": {
    "valor": numero_ou_0,
    "categoria": "categoria_ou_vazio",
    "descricao": "descri√ß√£o_natural_do_gasto",
    "data": "YYYY-MM-DD",
    "isValid": true_se_valor_E_categoria_identificados_E_confirmados
  },
  "personalityUpdate": "observacoes_sobre_o_jeito_do_usuario_falar"
}

EXEMPLOS DE FLUXO COMPLETO:
Usu√°rio: "gastei 200"
Bot: "Opa, R$ 200 anotado! Em que categoria?"
Usu√°rio: "hamb√∫rguer"  
Bot: "Show! R$ 200 no hamb√∫rguer! T√° certo?" (isValid: false - aguardando confirma√ß√£o)
Usu√°rio: "ta sim"
Bot: "Massa! R$ 200 em alimenta√ß√£o registrado! üéâ" (isValid: true - confirma e registra)

IMPORTANTE: 
- SEMPRE confirme antes de registrar gastos
- ENTENDA confirma√ß√µes do usu√°rio
- Celebre quando confirmado e registrado
- JSON v√°lido SEMPRE`;

    try {
      const messages: ChatMessage[] = [
        { role: 'system', content: extractionPrompt },
        { role: 'user', content: userMessage }
      ];

      const result = await this.chatCompletion(messages);
      console.log('OpenAI raw response:', result);
      
      // SISTEMA DE CONFIRMA√á√ÉO (PRIORITY #1)
      const currentMessage = userMessage.toLowerCase();
      const confirmationWords = ['sim', 'ta sim', 't√° sim', 'certo', 'isso mesmo', 'exato', 'correto', 'confirmo', 'pode ser', 't√° certo', '√© isso', 'isso a√≠', 'ta certo'];
      const isConfirmation = confirmationWords.some(word => currentMessage.includes(word));
      
      console.log(`‚ùì Verificando confirma√ß√£o para: "${userMessage}"`);
      console.log(`‚úÖ √â confirma√ß√£o? ${isConfirmation}`);
      
      if (isConfirmation) {
        // Buscar a √∫ltima mensagem do bot que pediu confirma√ß√£o
        const botMessages = conversationHistory.filter(msg => msg.type === 'assistant');
        const lastBotMessage = botMessages[botMessages.length - 1];
        
        console.log(`ü§ñ √öltima mensagem do bot: "${lastBotMessage?.content}"`);
        
        if (lastBotMessage && lastBotMessage.content.includes('T√° certo?')) {
          // Extrair valor e categoria da mensagem do bot
          const valorMatch = lastBotMessage.content.match(/R\$\s*(\d+(?:[.,]\d+)?)/);
          const categoriaMatch = lastBotMessage.content.match(/em\s+(\w+)/i);
          
          console.log(`üí∞ Valor extra√≠do: ${valorMatch?.[1]}`);
          console.log(`üè∑Ô∏è Categoria extra√≠da: ${categoriaMatch?.[1]}`);
          
          if (valorMatch && categoriaMatch) {
            const valor = parseFloat(valorMatch[1].replace(',', '.'));
            let categoria = categoriaMatch[1].toLowerCase();
            
            // Mapear categorias corretamente
            console.log(`üîß Categoria original detectada: "${categoria}"`);
            
            // Validar se √© uma categoria v√°lida ou mapear para a correta
            const validCategories = ['tecnologia', 'alimenta√ß√£o', 'vestu√°rio', 'transporte', 'mercado', 'lazer', 'sa√∫de', 'casa', 'contas', 'educa√ß√£o', 'beleza', 'pets'];
            
            if (!validCategories.includes(categoria)) {
              // Mapear para categoria correta
              if (categoria.includes('aliment') || categoria.includes('hamburg') || categoria.includes('comida')) {
                categoria = 'alimenta√ß√£o';
              } else if (categoria.includes('tecnolog') || categoria.includes('computador')) {
                categoria = 'tecnologia';
              } else if (categoria.includes('pet') || categoria.includes('veterinar')) {
                categoria = 'pets';
              } else {
                categoria = 'outros';
              }
            }
            
            console.log(`üéâ CONFIRMA√á√ÉO PROCESSADA: R$ ${valor} em ${categoria}`);
            
            return {
              response: `Show demais! R$ ${valor.toFixed(2)} em ${categoria} registrado! üéâ Gasto salvo com sucesso!\n\nE a√≠, rolou mais algum gasto hoje que voc√™ quer anotar? üòä`,
              extraction: {
                valor: valor,
                categoria: categoria,
                descricao: `Gasto em ${categoria}`,
                data: new Date().toISOString().split('T')[0],
                isValid: true // CONFIRMA E REGISTRA!
              }
            };
          }
        }
      }
      
      // DETEC√á√ÉO DE RESPOSTAS NEGATIVAS (n√£o tem mais gastos)
      const negativeWords = ['nao', 'n√£o', 'nada', 'sem', 'rolou nao', 'rolou n√£o', 'n√£o rolou', 'nao rolou', 'por hoje n√£o', 'hoje n√£o', 'sem mais', 'acabou', 's√≥ isso'];
      const isNegative = negativeWords.some(word => currentMessage.includes(word));
      
      console.log(`‚ùå Verificando negativa para: "${userMessage}"`);
      console.log(`‚ùå √â negativa? ${isNegative}`);
      
      if (isNegative) {
        // Verificar se a pergunta anterior foi sobre mais gastos
        const botMessages = conversationHistory.filter(msg => msg.type === 'assistant');
        const lastBotMessage = botMessages[botMessages.length - 1];
        
        if (lastBotMessage && lastBotMessage.content.includes('mais algum gasto')) {
          return {
            response: 'Show! Qualquer coisa, se aparecer mais algum gasto, √© s√≥ me chamar! T√¥ sempre aqui pra te ajudar! üòä‚úåÔ∏è',
            extraction: {
              valor: 0,
              categoria: '',
              descricao: '',
              data: new Date().toISOString().split('T')[0],
              isValid: false
            }
          };
        }
      }
      
      // DETEC√á√ÉO DE SAUDA√á√ïES E CUMPRIMENTOS
      const greetingWords = ['ola', 'ol√°', 'oi', 'eai', 'e ai', 'bom dia', 'boa tarde', 'boa noite', 'hey', 'hello', 'salve', 'fala'];
      const isGreeting = greetingWords.some(word => currentMessage.includes(word));
      
      console.log(`üëã Verificando sauda√ß√£o para: "${userMessage}"`);
      console.log(`üëã √â sauda√ß√£o? ${isGreeting}`);
      
      if (isGreeting) {
        const greetingResponses = [
          'E a√≠! Beleza? üòÑ Pronto pra anotar uns gastos? Manda a√≠: "gastei R$ 50 no mercado" ou algo assim! üí∞',
          'Opa! Tudo j√≥ia? üòä Vamos registrar seus gastos? √â s√≥ falar: "gastei R$ 30 no lanche" que eu anoto tudo! üçîüí∏',
          'Salve! Show de bola! ü§ô Bora organizar as finan√ßas? Fala a√≠ qualquer gasto: "gastei R$ 100 na roupa"! üëï',
          'E a√≠, tranquilo? üòé T√¥ aqui pra te ajudar com os gastos! Manda qualquer coisa tipo: "gastei R$ 80 no uber"! üöó',
          'Opa! Beleza demais! üéâ Pronto pra registrar uns gastos maneiros? S√≥ falar: "gastei R$ 25 no a√ßa√≠"! üç®'
        ];
        
        const randomResponse = greetingResponses[Math.floor(Math.random() * greetingResponses.length)];
        
        return {
          response: randomResponse,
          extraction: {
            valor: 0,
            categoria: '',
            descricao: '',
            data: new Date().toISOString().split('T')[0],
            isValid: false
          }
        };
      }
      
      // DETEC√á√ÉO DE CONFIRMA√á√ïES CONVERSACIONAIS (respostas positivas ap√≥s sauda√ß√£o)
      const conversationalWords = ['vamos', 'bora', 'ok', 'beleza', 'sim', 'claro', 'dale', 'show', 'massa', 'vamo', 'bora l√°', 'pode ser', 'tranquilo', 'fechou'];
      const isConversational = conversationalWords.some(word => currentMessage.includes(word));
      
      console.log(`üí¨ Verificando resposta conversacional para: "${userMessage}"`);
      console.log(`üí¨ √â conversacional? ${isConversational}`);
      
      if (isConversational) {
        // Verificar se a mensagem anterior do bot foi uma sauda√ß√£o
        const botMessages = conversationHistory.filter(msg => msg.type === 'assistant');
        const lastBotMessage = botMessages[botMessages.length - 1];
        
        if (lastBotMessage && (lastBotMessage.content.includes('Pronto pra anotar') || lastBotMessage.content.includes('Vamos registrar'))) {
          const readyResponses = [
            'Show! üéâ Ent√£o me fala a√≠, qual foi o √∫ltimo gasto que voc√™ fez? Pode ser qualquer coisa: comida, roupa, transporte... üí∞',
            'Massa! üòä Vamos l√° ent√£o! Me conta, gastou com o qu√™ hoje? Almo√ßo? Uber? Compras? üõí',
            'Dahora! üöÄ Bora anotar! Qual foi a √∫ltima vez que voc√™ abriu a carteira? Me fala a√≠! üí≥',
            'Top! üî• Perfeito! Ent√£o me conta: qual foi o gasto mais recente? Pode ser desde um caf√© at√© uma compra maior! ‚òïüí∏',
            'Beleza! ü§ô Vamos organizar essas finan√ßas! Me fala qualquer gasto que voc√™ lembra... o que rolou? üìä'
          ];
          
          const randomResponse = readyResponses[Math.floor(Math.random() * readyResponses.length)];
          
          return {
            response: randomResponse,
            extraction: {
              valor: 0,
              categoria: '',
              descricao: '',
              data: new Date().toISOString().split('T')[0],
              isValid: false
            }
          };
        }
      }
      
      // DETEC√á√ÉO DE CONVERSAS VAGAS (quando n√£o entende o contexto)
      const vagueWords = ['sim', 'n√£o', 'ok', 'certo', 'talvez', 'pode ser'];
      const isVague = vagueWords.some(word => currentMessage === word.toLowerCase()) && !isConfirmation;
      
      if (isVague) {
        const helpResponses = [
          'Hmm, n√£o entendi muito bem... ü§î Voc√™ quer anotar algum gasto? Me fala tipo: "gastei R$ 30 no almo√ßo"! üçΩÔ∏è',
          'Opa, ficou meio vago a√≠! üòÖ T√° querendo registrar alguma despesa? Fala a√≠: "comprei uma camisa por R$ 80"! üëï',
          'N√£o t√¥ sacando... üßê Bora ser mais espec√≠fico? Me conta algum gasto: "paguei R$ 15 no uber"! üöó',
          'Meio confuso aqui! üòµ Voc√™ gastou alguma coisa que quer anotar? Tipo: "gastei R$ 50 no mercado"! üõí'
        ];
        
        const randomResponse = helpResponses[Math.floor(Math.random() * helpResponses.length)];
        
        return {
          response: randomResponse,
          extraction: {
            valor: 0,
            categoria: '',
            descricao: '',
            data: new Date().toISOString().split('T')[0],
            isValid: false
          }
        };
      }
      
      // PRIORIZAR RESPOSTA DA OpenAI - ELA √â INTELIGENTE!
      try {
        // Clean the response to ensure it's valid JSON
        let cleanedResult = result.trim();
        if (!cleanedResult.startsWith('{')) {
          const jsonMatch = cleanedResult.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            cleanedResult = jsonMatch[0];
          } else {
            // FALLBACK SIMPLES: s√≥ se OpenAI falhar completamente
            console.log('OpenAI n√£o retornou JSON v√°lido, usando fallback');
            const numberMatch = userMessage.match(/\d+(?:[.,]\d+)?/);
            const valor = numberMatch ? parseFloat(numberMatch[0].replace(',', '.')) : 0;
            
            return {
              response: valor > 0 ? 
                `Opa, R$ ${valor.toFixed(2)} anotado! Mas em que categoria rolou esse gasto? (alimenta√ß√£o, vestu√°rio, transporte...)` :
                'Opa, n√£o consegui sacar direito... Pode falar tipo "gastei R$ 50 no mercado"? üòÖ',
              extraction: {
                valor: valor,
                categoria: '',
                descricao: valor > 0 ? 'Gasto a categorizar' : 'Gasto',
                data: new Date().toISOString().split('T')[0],
                isValid: false
              }
            };
          }
        }
        
        const parsed = JSON.parse(cleanedResult);
        
        // USAR DIRETAMENTE A RESPOSTA DA OpenAI - ELA SABE O QUE FAZ!
        return {
          response: parsed.response || 'Opa, n√£o consegui sacar direito... Pode falar tipo "gastei R$ 50 no mercado"? üòÖ',
          extraction: {
            valor: parsed.extraction?.valor || 0,
            categoria: parsed.extraction?.categoria || '',
            descricao: parsed.extraction?.descricao || 'Gasto',
            data: parsed.extraction?.data || new Date().toISOString().split('T')[0],
            isValid: parsed.extraction?.isValid || false
          },
          personalityUpdate: parsed.personalityUpdate || ''
        };
      } catch (parseError) {
        console.error('Error parsing OpenAI response:', parseError);
        return {
          response: 'Opa, n√£o consegui sacar direito... Pode falar tipo "gastei R$ 50 no mercado"? üòÖ',
          extraction: {
            valor: 0,
            categoria: '',
            descricao: 'Gasto',
            data: new Date().toISOString().split('T')[0],
            isValid: false
          }
        };
      }
    } catch (error) {
      console.error('Error extracting expense data:', error);
      throw error;
    }
  }
}
